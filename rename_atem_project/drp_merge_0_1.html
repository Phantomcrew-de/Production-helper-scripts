<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>DRP‑Merger (JSON & XML)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    :root{--brand:#0ea5e9;--bg:#f8fafc;--border:#cbd5e1;--text:#0f172a}
    *{box-sizing:border-box}
    body{font-family:system-ui,sans-serif;background:var(--bg);margin:0;padding:1rem;display:flex;flex-direction:column;align-items:center;min-height:100vh;color:var(--text)}
    h1{text-align:center;margin:0 0 1rem}
    #dropzone{width:min(95%,500px);height:200px;border:3px dashed var(--border);border-radius:16px;display:flex;align-items:center;justify-content:center;text-align:center;padding:1rem;background:#fff;transition:.2s}
    #dropzone.dragover{background:#e0f2fe;border-color:var(--brand)}
    #downloadBtn{margin-top:1.5rem;padding:.75rem 1.25rem;font-size:1rem;border:none;background:var(--brand);color:#fff;border-radius:12px;cursor:pointer;display:none;text-decoration:none}
    #status{margin-top:1rem;white-space:pre-line;max-width:600px}
    small{color:#64748b}
    /* Overlay Dialog */
    #overlay{position:fixed;inset:0;background:rgba(0,0,0,.4);display:flex;align-items:center;justify-content:center;visibility:hidden;opacity:0;transition:.3s;z-index:1000}
    #overlay.show{visibility:visible;opacity:1}
    #dialog{background:#fff;width:clamp(300px,95%,900px);max-height:90vh;border-radius:18px;overflow:hidden;display:flex;flex-direction:column;box-shadow:0 10px 30px rgba(0,0,0,.2)}
    #dialog header{padding:1rem;border-bottom:1px solid var(--border);display:flex;flex-direction:column;gap:.5rem}
    #dialog h2{margin:0;font-size:1.2rem}
    #searchBar{display:flex;gap:.5rem}
    #searchBar input{flex:1;padding:.5rem;border:1px solid var(--border);border-radius:8px}
    #renameTable{flex:1;overflow:auto}
    table{width:100%;border-collapse:collapse;font-size:.9rem}
    th,td{padding:.4rem .6rem;border-bottom:1px solid var(--border)}
    tr:nth-child(even){background:#f1f5f9}
    td.chk{text-align:center}
    input.rename{width:100%;padding:.3rem;border:1px solid var(--border);border-radius:6px}
    #dialog footer{padding:.8rem 1rem;border-top:1px solid var(--border);display:flex;justify-content:flex-end;gap:.5rem}
    button{padding:.5rem 1rem;border:none;border-radius:8px;cursor:pointer;font-size:.9rem}
    .secondary{background:#e2e8f0}
    .primary{background:var(--brand);color:#fff}
  </style>
</head>
<body>
  <h1>DRP‑Dateien zusammenführen</h1>
  <div id="dropzone">Dateien hierher ziehen<br><small>(.drp ZIP/XML oder .drp JSON)</small></div>
  <a id="downloadBtn" download="merged.drp">Zusammengeführte Datei herunterladen</a>
  <div id="status"></div>

  <!-- Konflikt-Overlay -->
  <div id="overlay">
    <div id="dialog">
      <header>
        <h2>Namen anpassen</h2>
        <div id="searchBar">
          <input id="findInput" placeholder="Suchen …" />
          <input id="replaceInput" placeholder="Ersetzen durch …" />
          <button id="replaceBtn" class="secondary">Alle ersetzen</button>
        </div>
      </header>
      <div id="renameTable">
        <table>
          <thead>
            <tr><th>Übernehmen</th><th>Alter Name</th><th>Neuer Name</th><th>Quelle</th></tr>
          </thead>
          <tbody id="renameBody"></tbody>
        </table>
      </div>
      <footer>
        <button id="cancelBtn" class="secondary">Abbrechen</button>
        <button id="okBtn" class="primary">Übernehmen</button>
      </footer>
    </div>
  </div>

<script>
/* ========= Einstellungen ========= */
const NAME_WHITELIST = ["Black","Color 1","Color 2","Color Bars"];

/* ========= DOM-Elemente ========= */
const dropzone = document.getElementById('dropzone');
const statusBox = document.getElementById('status');
const downloadBtn = document.getElementById('downloadBtn');

const overlay = document.getElementById('overlay');
const renameBody = document.getElementById('renameBody');
const okBtn = document.getElementById('okBtn');
const cancelBtn = document.getElementById('cancelBtn');
const findInput = document.getElementById('findInput');
const replaceInput = document.getElementById('replaceInput');
const replaceBtn = document.getElementById('replaceBtn');

/* ========= Helfer ========= */
function log(msg){ statusBox.textContent += msg + "\n"; }
function showOverlay(){ overlay.classList.add('show'); }
function hideOverlay(){ overlay.classList.remove('show'); }

/* ========= Drag & Drop ========= */
dropzone.addEventListener('dragover', e => { e.preventDefault(); dropzone.classList.add('dragover'); });
dropzone.addEventListener('dragleave', () => dropzone.classList.remove('dragover'));
dropzone.addEventListener('drop', handleDrop);

/* ========= Kernlogik ========= */
async function handleDrop(e){
  e.preventDefault(); dropzone.classList.remove('dragover');
  const files = [...e.dataTransfer.files];
  if(files.length < 2){ alert('Bitte mindestens zwei Dateien ablegen.'); return; }
  statusBox.textContent = '';
  log('Analysiere ' + files.length + ' Dateien …');

  try{
    const infos = await Promise.all(files.map(readFileInfo));
    const types = new Set(infos.map(i => i.type));
    if(types.size !== 1){ alert('Alle Dateien müssen vom selben Typ sein (alle JSON- oder alle ZIP/XML-basiert).'); return; }
    const type = infos[0].type;

    if(type === 'json'){
      const allDocs = [];
      infos.forEach(info => { log('✓ ' + info.name + ' (JSON)'); allDocs.push({docs: info.docs, name: info.name}); });
      const mergedText = await mergeJsonInteractive(allDocs);
      const blob = new Blob([mergedText], {type: 'application/json'});
      prepareDownload(blob, 'merged_json.drp');
    }else{
      const xmlInfos = infos.map(i => ({xml: i.xml, name: i.name}));
      xmlInfos.forEach(i => log('✓ ' + i.name + ' (ZIP/XML)'));
      const mergedXml = await mergeXmlInteractive(xmlInfos);
      const zip = new JSZip();
      zip.file('project.xml', mergedXml);
      const blob = await zip.generateAsync({type:'blob'});
      prepareDownload(blob, 'merged_xml.drp');
    }

  }catch(err){ console.error(err); alert('Fehler: ' + err.message); }
}

function prepareDownload(blob, filename){
  const url = URL.createObjectURL(blob);
  downloadBtn.href = url;
  downloadBtn.download = filename;
  downloadBtn.style.display = 'inline-block';
  log('\nFertig!');
}

/* ========= File Parsing ========= */
async function readFileInfo(file){
  const header = new Uint8Array(await file.slice(0,4).arrayBuffer());
  const isZip = header[0] === 0x50 && header[1] === 0x4b; // PK
  if(isZip){
    const zip = await JSZip.loadAsync(await file.arrayBuffer());
    const projFile = zip.file(/project\.xml$/i)[0];
    if(!projFile) throw new Error(file.name + ': keine project.xml gefunden');
    const xmlText = await projFile.async('text');
    const xmlDoc = new DOMParser().parseFromString(xmlText, 'application/xml');
    return {type:'xmlzip', name:file.name, xml:xmlDoc};
  }else{
    const text = await file.text();
    const docs = parseConcatJson(text);
    if(!docs.length) throw new Error(file.name + ': kein gültiges JSON gefunden');
    return {type:'json', name:file.name, docs};
  }
}

function parseConcatJson(text){
  const list = []; let depth = 0, start = 0, inStr = false;
  for(let i=0;i<text.length;i++){
    const ch = text[i];
    if(ch === '"' && text[i-1] !== '\\') inStr = !inStr;
    if(!inStr && ch === '{') depth++;
    if(!inStr && ch === '}'){ depth--; if(depth===0){ const piece = text.slice(start,i+1).trim(); if(piece){ try{ list.push(JSON.parse(piece)); }catch{} } start=i+1; } }
  }
  return list;
}

/* ========= Konflikt-Dialog ========= */
let conflicts = [];
function buildDialogRows(){
  renameBody.innerHTML = '';
  conflicts.forEach((c,i) => {
    const tr = document.createElement('tr');
    const disabled = NAME_WHITELIST.includes(c.old);
    const checked = !disabled && c.apply;
    tr.innerHTML = `<td class="chk"><input type="checkbox" ${checked?"checked":""} ${disabled?"disabled":""}></td>` +
                   `<td>${c.old}</td>` +
                   `<td><input class="rename" value="${c.new}" ${disabled?"disabled":""}></td>` +
                   `<td>${c.source}</td>`;
    renameBody.appendChild(tr);
  });
}

function showRenameDialog(){
  buildDialogRows();
  return new Promise(resolve => {
    showOverlay();
    okBtn.onclick = () => {
      const rows = [...renameBody.querySelectorAll('tr')];
      rows.forEach((row,idx) => {
        const chk = row.querySelector('input[type=checkbox]');
        const inp = row.querySelector('input.rename');
        conflicts[idx].apply = chk ? chk.checked : true;
        conflicts[idx].final = inp ? inp.value.trim() : conflicts[idx].old;
      });
      hideOverlay(); resolve(true);
    };
    cancelBtn.onclick = () => { hideOverlay(); resolve(false); };
    replaceBtn.onclick = () => {
      const find = findInput.value;
      const repl = replaceInput.value;
      if(!find) return;
      [...renameBody.querySelectorAll('input.rename:not([disabled])')].forEach(inp => {
        inp.value = inp.value.replaceAll(find, repl);
      });
    };
  });
}

/* ========= JSON-Merge ========= */
async function mergeJsonInteractive(fileDocs){
  const base = structuredClone(fileDocs[0].docs[0]);
  if(!Array.isArray(base.sources)) base.sources = [];
  const existing = new Map(base.sources.map(s=>[s.name,s]));
  let idxOffset = base.sources.length;
  conflicts = [];
  const adds = [];
  for(let fIdx=0; fIdx<fileDocs.length; fIdx++){
    const {docs, name:srcName} = fileDocs[fIdx];
    docs.forEach(doc => {
      if(!Array.isArray(doc.sources)) return;
      doc.sources.forEach(src => {
        if(NAME_WHITELIST.includes(src.name)){
          // Whitelist -> falls noch nicht vorhanden, hinzufügen, sonst ignorieren
          if(!existing.has(src.name)){
            const clone = structuredClone(src);
            clone._index_ = idxOffset++;
            base.sources.push(clone);
            existing.set(clone.name, clone);
          }
          return;
        }
        if(existing.has(src.name)){
          conflicts.push({old:src.name, new:src.name+"_kopie", source:srcName, obj:src, apply:true});
        }else{
          adds.push({src, source:srcName});
          existing.set(src.name, src);
        }
      });
    });
  }

  if(conflicts.length){
    const proceed = await showRenameDialog();
    if(!proceed) throw new Error('Abbruch durch Benutzer');
    conflicts.forEach(c => {
      if(c.apply){
        const clone = structuredClone(c.obj);
        clone.name = c.final;
        clone._index_ = idxOffset++;
        base.sources.push(clone);
      }
    });
  }
  adds.forEach(a => {
    const clone = structuredClone(a.src);
    clone._index_ = idxOffset++;
    base.sources.push(clone);
  });
  // Neu nummerieren
  base.sources.forEach((s,i) => s._index_ = i);
  return JSON.stringify(base);
}

/* ========= XML-Merge ========= */
async function mergeXmlInteractive(xmlInfos){
  const baseDoc = xmlInfos[0].xml;
  const baseRoot = baseDoc.documentElement;
  const existingNames = new Set([...baseRoot.querySelectorAll('[name]')].map(n => n.getAttribute('name')));
  conflicts = [];
  const toAppend = [];
  for(let i=1;i<xmlInfos.length;i++){
    const {xml, name:srcName} = xmlInfos[i];
    const root = xml.documentElement;
    [...root.children].forEach(node => {
      if(node.nodeType !== 1) return;
      const imported = baseDoc.importNode(node, true);
      const nameAttr = imported.getAttribute('name');
      if(NAME_WHITELIST.includes(nameAttr)){
        if(!existingNames.has(nameAttr)){ toAppend.push(imported); existingNames.add(nameAttr); }
        return;
      }
      if(nameAttr && existingNames.has(nameAttr)){
        conflicts.push({old:nameAttr, new:nameAttr+' (2)', source:srcName, node:imported, apply:true});
      }else{
        toAppend.push(imported); if(nameAttr) existingNames.add(nameAttr);
      }
    });
  }
  if(conflicts.length){
    const proceed = await showRenameDialog();
    if(!proceed) throw new Error('Abbruch durch Benutzer');
    conflicts.forEach(c => {
      if(c.apply){
        c.node.setAttribute('name', c.final);
        toAppend.push(c.node);
      }
    });
  }
  toAppend.forEach(n => baseRoot.appendChild(n));
  return new XMLSerializer().serializeToString(baseDoc);
}
</script>
</body>
</html>
